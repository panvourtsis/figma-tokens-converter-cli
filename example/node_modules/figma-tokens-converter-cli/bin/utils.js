"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.returnImports = exports.recursiveDotNotationToSquareBackets = exports.recursiveWrite = exports.writeFile = void 0;
var fs_1 = __importDefault(require("fs"));
var path_1 = require("path");
var lodash_1 = __importDefault(require("lodash"));
var flatten_1 = __importDefault(require("lodash/flatten"));
var flow_1 = __importDefault(require("lodash/flow"));
var head_1 = __importDefault(require("lodash/head"));
var isObject_1 = __importDefault(require("lodash/isObject"));
var reduce_1 = __importDefault(require("lodash/reduce"));
var uniq_1 = __importDefault(require("lodash/uniq"));
var values_1 = __importDefault(require("lodash/values"));
var log_1 = __importDefault(require("./helpers/log"));
var writeFile = function (path, contents, cb) {
    fs_1.default.mkdir((0, path_1.dirname)(path), { recursive: true }, function (err) {
        if (err) {
            return cb(err);
        }
        return fs_1.default.writeFile(path, contents, cb);
    });
};
exports.writeFile = writeFile;
var recursiveWrite = function (data, output, expands, outputExtension) {
    if (expands === void 0) { expands = []; }
    if (outputExtension === void 0) { outputExtension = 'ts'; }
    lodash_1.default.keys(data).forEach(function (key) {
        var keyFoundOnExpanded = expands.includes(key);
        if (keyFoundOnExpanded) {
            (0, exports.recursiveWrite)(lodash_1.default.get(data, key), "".concat(output + key, "/"), expands, outputExtension);
        }
        else {
            var filePath_1 = "".concat(output).concat(key, ".").concat(outputExtension);
            (0, exports.writeFile)(filePath_1, JSON.stringify(lodash_1.default.get(data, key), null, 4), function () {
                log_1.default.success('done converting -', filePath_1);
            });
        }
    });
};
exports.recursiveWrite = recursiveWrite;
var recursiveDotNotationToSquareBackets = function (obj, tranformFileNameFun) {
    return lodash_1.default.cloneDeepWith(obj, function (v) {
        if (!lodash_1.default.isObject(v)) {
            if (/\{|\}/gi.test(v)) {
                return "{".concat(v
                    .replace(/{|\}/gi, '')
                    .split('.')
                    .map(function (val, index) {
                    return index === 0 ? tranformFileNameFun(val) : "['".concat(val, "']");
                })
                    .join(''), "}");
            }
            return v;
        }
    });
};
exports.recursiveDotNotationToSquareBackets = recursiveDotNotationToSquareBackets;
var returnImports = function (data) {
    return (0, flow_1.default)(values_1.default, function (data) {
        return (0, reduce_1.default)(data, function (acc, val) {
            if ((0, isObject_1.default)(val)) {
                acc = __spreadArray(__spreadArray([], acc, true), (0, exports.returnImports)(val), true);
            }
            else if (val.match(/\{|\}/gi)) {
                var matchedVal = (0, head_1.default)(val.replace(/\{|\}/gi, '').split('.'));
                if (matchedVal) {
                    acc.push(matchedVal);
                }
            }
            return (0, uniq_1.default)(acc);
        }, []);
    }, flatten_1.default, uniq_1.default)(data);
};
exports.returnImports = returnImports;
